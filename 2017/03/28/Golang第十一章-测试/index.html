<html><head><meta name="generator" content="Hexo 3.9.0"><title>Golang第十一章-测试</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">Golang第十一章-测试</h2><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#测试函数"><span class="toc-text">测试函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#随机测试"><span class="toc-text">随机测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#白盒测试"><span class="toc-text">白盒测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试扩展包"><span class="toc-text">测试扩展包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基准测试"><span class="toc-text">基准测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例函数"><span class="toc-text">示例函数</span></a></li></ol><ul><li>命令<ul><li>go test</li><li>遍历*_test.go 文件中复合规则的函数</li></ul></li><li>类型<ul><li>测试函数：Test开头用于测试程序逻辑行为的正确性</li><li>基准测试函数：Benchmark开头，用于衡量函数的性能，go test会运行多次取平均的执行时间</li><li>示例函数：Examole开头的函数，提供一个有编译器保证正确性的示例文档</li></ul></li></ul><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a>测试函数</h2><ul><li><p>导入的包和形式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &quot;testing&quot;</span><br><span class="line">func TestName(t *testing)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>go test -v参数可以打印每个测试函数的名字和运行时间</p></li><li>go test -run 对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被go test测试命令运行。</li><li>t.Error不能终止测试，t.Fatal可以终止测试</li><li>t.Fatal必须和测试函数在同一个groutine里调用才能终止测试</li><li>一般测试失败的信息形式为<code>f(x)=y, want z</code></li></ul><a id="more"></a><h3 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a>随机测试</h3><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ul><li>在测试一些诸如邮件发送函数的时候，我们并不想真正的发送邮件，因此可以将发送函数作为一个包级的私有函数值，然后在测试代码里先用修改该函数值，进行同等效果的测试<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fakefunc.go</span></span><br><span class="line"><span class="keyword">package</span> ch11</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> realFunc = <span class="function"><span class="keyword">func</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Real Func:%s\n"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckInfo</span><span class="params">(data <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    realFunc(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//fakefunc_test</span></span><br><span class="line"><span class="keyword">package</span> ch11</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFakeFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">string</span></span><br><span class="line">    saved := realFunc <span class="comment">//保存原来的realfunc</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; realFunc = saved &#125;()</span><br><span class="line">    realFunc = <span class="function"><span class="keyword">func</span><span class="params">(d <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        data = d + <span class="string">"demo"</span></span><br><span class="line">    &#125;</span><br><span class="line">    CheckInfo(<span class="string">"demo"</span>)</span><br><span class="line">    <span class="keyword">if</span> data != <span class="string">"demo"</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">`data=%s want "demo"`</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试扩展包"><a href="#测试扩展包" class="headerlink" title="测试扩展包"></a>测试扩展包</h3><p>一个测试包想要使用，调用了该包的函数，这样讲形成一个包循环，go是不允许的，因此可以在被调用包的目录创建一个<code>&lt;path&gt;/&lt;package&gt;_test</code>的目录。告诉go test工具应该建立一个额外的包运行测试。这样就可以在该包内倒入测试代码依赖的其他的辅助包</p><ul><li><p>go list 可以查看哪些是Go源文件产品代码，哪些是包测试，哪些是测试扩展包。</p><ul><li>go list -f={ {.GoFiles} } fmt。GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分</li><li>go list -f={ {.TestGoFiles} } fmt fmt。TestGoFiles表示包内部测试代码，以_test.go为后缀文件名，不过只是在测试时被构建</li><li>go list -f={ {.XTestGoFiles} } fmt。XTestGoFiles表示属于测试扩展包的测试代码，也就是fmt_test</li></ul></li><li><p>测试覆盖率</p><ul><li>go test -coverprofile=c.out</li><li>coverprofile参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说在运行每个测试前。他会修改测试代码的副本，在每个词法块都会设置一个布尔标志变量。当被修改后的的被测试代码运行退出时，讲统计日志数据写入到c.out文件，并打印一部分执行的语句的一个总结。如果你需要的是摘要使用go test -cover</li><li>-covermod=count可以在每个代码块插入计数器。统计每个块的执行次数，从而可以知道执行的热点代码</li><li>go tool cover -html=c.out可以生成一个HTML报告</li></ul></li></ul><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><ul><li>Benchmark开头，参数是b *testing.B,其中b有一个变量N，用于指定操作循环的次数。系统自己指定,会自己调整<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;testing&quot;</span><br><span class="line">func BenchmarkIsPalindrome(b *testing.B) &#123;</span><br><span class="line">    for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">        IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>循环放在测试函数内部，而不是放在测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间</p><ul><li>go test -bench=. 需要通过bench标志指定要运行的基准测试函数。支持正则，默认是空。<code>.</code>表示匹配所有基准测试函数</li><li>-benchmem命令行标志参数可以在报告中包含内存的分配数据统计</li><li>可以通过go tool pprof对操作系统信息进行采样，比如cpu,内存占用.可以参考<a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">Profiling Go Programs</a></li></ul><h2 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a>示例函数</h2><ul><li><p>以Example开头，没有参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func ExampleIsPalindrome() &#123;</span><br><span class="line">    fmt.Println(IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;))</span><br><span class="line">    fmt.Println(IsPalindrome(&quot;palindrome&quot;))</span><br><span class="line">    // Output:</span><br><span class="line">    // true</span><br><span class="line">    // false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为文档，godoc会根据示例函数的后缀名部分，将一个示例函数关联到某个具体函数或包本身</p><ul><li>go test会运行示例函数，如果含有上面Output的注释，那么测试工具会比较输出结果和注释是否一致</li><li>提供一个真实的演练场，像<a href="http://golang.org" target="_blank" rel="noopener">http://golang.org</a>一样就是有godoc提供的文档服务，他使用了Go Playground提高的技术让用户可以在浏览器中在线编辑和运行每个示例函数</li></ul></li></ul><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>