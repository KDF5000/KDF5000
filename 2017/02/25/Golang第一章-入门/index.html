<html><head><meta name="generator" content="Hexo 3.9.0"><title>Golang第一章:入门</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">Golang第一章:入门</h2><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#os-Args获取参数"><span class="toc-text">os.Args获取参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for循环"><span class="toc-text">for循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#是否存在某子串，子串出现次数"><span class="toc-text">是否存在某子串，子串出现次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串的分割"><span class="toc-text">字符串的分割</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Fileds和FiledsFunc"><span class="toc-text">Fileds和FiledsFunc</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Split-和-SplitAfter、-SplitN-和-SplitAfterN"><span class="toc-text">Split 和 SplitAfter、 SplitN 和 SplitAfterN</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串数组-或slice-的连接"><span class="toc-text">字符串数组(或slice)的连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串替换"><span class="toc-text">字符串替换</span></a></li></ol></li></ol></li></ol><h3 id="os-Args获取参数"><a href="#os-Args获取参数" class="headerlink" title="os.Args获取参数"></a>os.Args获取参数</h3><p>os.Args 是一个字符串的切片，它的第一个元素os.Args[0]是命令本身的名字，其他元素则是程序启动时传给它的参数。</p><p>i++ 给i加1，是语句，而在c语言中则是表达式，因此在golang中j = i++ 是非法的。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for initialization; condition; post &#123;</span><br><span class="line">    // zero or more statements</span><br><span class="line">&#125;</span><br><span class="line">// a traditional &quot;while&quot; loop</span><br><span class="line">for condition &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>string 类型可以看成一种特殊的slice, 因此可以使用len获取长度，同时支持切片操作，但是对于单个元素，如a[0]的结果是一个byte，输出来是asiic码，需要string(a[0])这样转换，但是可以通过切片操作获取子串，如a[2:]</p><h4 id="是否存在某子串，子串出现次数"><a href="#是否存在某子串，子串出现次数" class="headerlink" title="是否存在某子串，子串出现次数"></a>是否存在某子串，子串出现次数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//contains 和containsAny都是调用Index来判断子串是否出现在字符串中</span><br><span class="line">    //空格隔开子串</span><br><span class="line">    fmt.Println(strings.ContainsAny(&quot;hello&quot;, &quot;s e&quot;)) //true</span><br><span class="line">    fmt.Println(strings.ContainsAny(&quot;hello&quot;, &quot;&quot;))    //false</span><br><span class="line">    fmt.Println(strings.ContainsAny(&quot;hello&quot;, &quot;lo&quot;))  //true</span><br><span class="line"></span><br><span class="line">    //count也就是字符串匹配实现的是Rabin-Karp算法，Count 是计算子串在字符串中出现的无重叠的次</span><br><span class="line">    fmt.Println(strings.Count(&quot;fivevev&quot;, &quot;ve&quot;))  //2</span><br><span class="line">    fmt.Println(strings.Count(&quot;fivevev&quot;, &quot;&quot;))    //8 utf8.RuneCountInString(s) + 1 也就是长度+1</span><br><span class="line">    fmt.Println(strings.Count(&quot;fivevev&quot;, &quot;vev&quot;)) //1</span><br></pre></td></tr></table></figure><h4 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h4><p>六个三组函数：Fields 和 FieldsFunc、Split 和 SplitAfter、SplitN 和 SplitAfterN</p><h5 id="Fileds和FiledsFunc"><a href="#Fileds和FiledsFunc" class="headerlink" title="Fileds和FiledsFunc"></a>Fileds和FiledsFunc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func Fields(s string) []string</span><br><span class="line">func FieldsFunc(s string, f func(rune) bool) []string</span><br></pre></td></tr></table></figure><p>Fields 用一个或多个连续的空格分隔字符串 s,返回子字符串的数组（slice）<br>由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;Fields are: %q&quot;, strings.Fields(&quot;  foo bar  baz   &quot;))</span><br></pre></td></tr></table></figure><p></p><p>输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fields are: [&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</span><br></pre></td></tr></table></figure><p></p><p>FieldsFunc 用这样的Unicode代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点(unicode code points)都满足f(c)或者 s 是空，则 FieldsFunc 返回空slice。<br>也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(strings.FieldsFunc(&quot;  foo bar  baz   &quot;, unicode.IsSpace))</span><br></pre></td></tr></table></figure><p></p><p>实际上，Fields 函数就是调用 FieldsFunc 实现的：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Fields(s string) []string &#123;</span><br><span class="line">    return FieldsFunc(s, unicode.IsSpace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="Split-和-SplitAfter、-SplitN-和-SplitAfterN"><a href="#Split-和-SplitAfter、-SplitN-和-SplitAfterN" class="headerlink" title="Split 和 SplitAfter、 SplitN 和 SplitAfterN"></a>Split 和 SplitAfter、 SplitN 和 SplitAfterN</h5><p>之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func Split(s, sep string) []string &#123; return genSplit(s, sep, 0, -1) &#125;</span><br><span class="line">func SplitAfter(s, sep string) []string &#123; return genSplit(s, sep, len(sep), -1) &#125;</span><br><span class="line">func SplitN(s, sep string, n int) []string &#123; return genSplit(s, sep, 0, n) &#125;</span><br><span class="line">func SplitAfterN(s, sep string, n int) []string &#123; return genSplit(s, sep, len(sep), n) &#125;</span><br></pre></td></tr></table></figure><p></p><p>Split和SplitAfter的区别是，After会保留分隔符<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//分割字符串</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.Split(&quot;foo,bar,baz&quot;, &quot;,&quot;))      //[&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</span><br><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitAfter(&quot;foo,bar,baz&quot;, &quot;,&quot;)) //[&quot;foo,&quot; &quot;bar,&quot; &quot;baz&quot;]</span><br></pre></td></tr></table></figure><p></p><pre><code>带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n &lt; 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n &gt; 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(&quot;%q\n&quot;, strings.SplitN(&quot;foo,bar,baz&quot;, &quot;,&quot;, 2))</span><br><span class="line">//[&quot;foot&quot; &quot;bar,baz&quot;]</span><br></pre></td></tr></table></figure><h5 id="字符串数组-或slice-的连接"><a href="#字符串数组-或slice-的连接" class="headerlink" title="字符串数组(或slice)的连接"></a>字符串数组(或slice)的连接</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func Join(a []string, sep string) string</span><br></pre></td></tr></table></figure><p>标准库的是实现方式<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func Join(a []string, sep string) string &#123;</span><br><span class="line">    if len(a) == 0 &#123;</span><br><span class="line">        return &quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    if len(a) == 1 &#123;</span><br><span class="line">        return a[0]</span><br><span class="line">    &#125;</span><br><span class="line">    n := len(sep) * (len(a) - 1)</span><br><span class="line">    for i := 0; i &lt; len(a); i++ &#123;</span><br><span class="line">        n += len(a[i])</span><br><span class="line">    &#125;</span><br><span class="line">    b := make([]byte, n)</span><br><span class="line">    bp := copy(b, a[0])</span><br><span class="line">    for _, s := range a[1:] &#123;</span><br><span class="line">        bp += copy(b[bp:], sep)</span><br><span class="line">        bp += copy(b[bp:], s)</span><br><span class="line">    &#125;</span><br><span class="line">    return string(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>标准库的实现没有用 bytes 包，当然也不会简单的通过 + 号连接字符串。Go 中是不允许循环依赖的，标准库中很多时候会出现代码拷贝，而不是引入某个包。这里 Join 的实现方式挺好，我个人猜测，不直接使用 bytes 包，也是不想依赖 bytes 包（其实 bytes 中的实现也是 copy 方式）。</p><h5 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h5><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 用 new 替换 s 中的 old，一共替换 n 个。</span><br><span class="line">// 如果 n &lt; 0，则不限制替换次数，即全部替换</span><br><span class="line">func Replace(s, old, new string, n int) string</span><br></pre></td></tr></table></figure></li></ul><p>只能替换一种string</p><ul><li>Replacer<br>这是一个结构，没有导出任何字段，实例化通过 func NewReplacer(oldnew …string) *Replacer 函数进行，其中不定参数 oldnew 是 old-new 对，即进行多个替换。<br>解决上面说的替换一种的问题：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r := strings.NewReplacer(&quot;&lt;&quot;, &quot;&amp;lt;&quot;, &quot;&gt;&quot;, &quot;&amp;gt;&quot;)</span><br><span class="line">fmt.Println(r.Replace(&quot;This is &lt;b&gt;HTML&lt;/b&gt;!&quot;))</span><br></pre></td></tr></table></figure></li></ul><p>另外，Replacer 还提供了另外一个方法：<br>func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)<br>它在替换之后将结果写入 io.Writer 中。</p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>