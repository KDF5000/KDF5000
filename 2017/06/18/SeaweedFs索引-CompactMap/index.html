<html><head><meta name="generator" content="Hexo 3.9.0"><title>SeaweedFs索引-CompactMap</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">SeaweedFs索引-CompactMap</h2><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#CompactMap"><span class="toc-text">CompactMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CompactSectionMap"><span class="toc-text">CompactSectionMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol><p>SeaweedFS提供了几种不同的needle索引策略，包括memory, btree, blotdb, leveldb四种，其中默认的是memory，也是其内部唯一自己实现的一种索引，btree使用google的btree开源实现，boltdb和leveldb都依赖一个db.</p><p>memory的索引实现，使用了一个叫CompactMap(这是作者自己起的名)的数据结构。本文后面将会重点介绍compactMap是一个怎样的数据结构，以及如何使用这个数据结构简历needle的索引。</p><a id="more"></a><h2 id="CompactMap"><a href="#CompactMap" class="headerlink" title="CompactMap"></a>CompactMap</h2><p>compactMap本质是一个数组(Golang中可以动态扩展的数组)，其元素类型是CompactSection，定义如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//This map assumes mostly inserting increasing keys</span></span><br><span class="line"><span class="keyword">type</span> CompactMap <span class="keyword">struct</span> &#123;</span><br><span class="line">    list []*CompactSection</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CompactMap结构体内部只有一个CompactSection的结构体的指针数组，那么为什么作者假设插入的key是增序的呢？我们先看CompactSection是一个什么样的结构，答案后面就会很清楚。<br>下面是CompactSection的结构：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CompactSection <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex                 <span class="comment">//读写锁</span></span><br><span class="line">    values   []NeedleValue       <span class="comment">//NeedleValue数组，保存了Needle的key, offset, size</span></span><br><span class="line">    overflow <span class="keyword">map</span>[Key]NeedleValue <span class="comment">//用于保存超出batch，但是在(start, end)范围的needleValue</span></span><br><span class="line">    start    Key                 <span class="comment">//该section保存的key最小值</span></span><br><span class="line">    end      Key                 <span class="comment">//该section保存的key最大值</span></span><br><span class="line">    counter  <span class="keyword">int</span>                 <span class="comment">//当前该section的needleValue的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>CompactSection保存了key值在[start, end]范围内的所有needleValue，每个section都会记录当前处于该段的所有needleValue数量，并且有一个固定的容量限制，目前版本的限制是100000，如果该段已经存储的needleValue已经达到了最大容量，但是其key那么就会将当前[start,end]范围，那么needleValue保存到map里，也就是说values数组最大长度为100000， 主要是因为当前使用二分搜索，查找key对应的needleValue, 所以数组还是不能太大。使用map也能够快速的定位。</p><p>上面简单介绍了compactSection的结构，先不管怎么向某个section插入一个needleValue, 我们只用知道一个compactSection保存从[start,end]范围内的所有needleValue。所以CompactMap的list就是将key分成一段一段管理，至于每一段的key是怎么管理的可以不用管，只用知道每个段的范围即可，当要插入一个key的时候，使用二分查找的方法找到该key所处的section, 然后插入到该section。</p><p>下面是二分查找的代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cm *CompactMap)</span> <span class="title">binarySearchCompactSection</span><span class="params">(key Key)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    l, h := <span class="number">0</span>, <span class="built_in">len</span>(cm.list)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> h &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cm.list[h].start &lt;= key &#123;</span><br><span class="line">        <span class="keyword">if</span> cm.list[h].counter &lt; batch || key &lt;= cm.list[h].end &#123;</span><br><span class="line">            <span class="keyword">return</span> h</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> l &lt;= h &#123;</span><br><span class="line">        m := (l + h) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &lt; cm.list[m].start &#123;</span><br><span class="line">            h = m - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// cm.list[m].start &lt;= key</span></span><br><span class="line">            <span class="keyword">if</span> cm.list[m+<span class="number">1</span>].start &lt;= key &#123;</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//貌似这里有bug, 如果处于(end, $$start_&#123;m+1&#125;$$), 则同样要插入一个新的section</span></span><br><span class="line">                <span class="comment">/*if(key &gt; cm.list[m].end)&#123;</span></span><br><span class="line"><span class="comment">                    return -5</span></span><br><span class="line"><span class="comment">                &#125;*/</span></span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面以上面的代码分析怎么找到一个NeedleValue应该插入的section:</p><ul><li>如果list为空则直接返回一个负值</li><li>先判断是否能够插入到最后一个section, 能够插入的条件是该key大于section的最小key值，如果当前section没有超过容量，或者超过了但是处于[start, end]范围，则返回当前section, 否则返回一个负值。</li><li>前两个条件都不满足的话，就二分搜索前面所有section能够插入的section, 如果到第一个section都没有找到，即key&lt; list[0].start， 说明需要插入一个新的section, 返回一个负值</li></ul><p>总的来说，搜索有两个结果，返回一个可以插入的section和返回一个负值，当返回一个负值的时候，就需要重新生成一个compactSection，使用插入排序的方法，将其插入到list<br>代码如下：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cm *CompactMap)</span> <span class="title">Set</span><span class="params">(key Key, offset, size <span class="keyword">uint32</span>)</span> <span class="params">(oldOffset, oldSize <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    x := cm.binarySearchCompactSection(key)</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//println(x, "creating", len(cm.list), "section, starting", key)</span></span><br><span class="line">        cm.list = <span class="built_in">append</span>(cm.list, NewCompactSection(key))</span><br><span class="line">        x = <span class="built_in">len</span>(cm.list) - <span class="number">1</span></span><br><span class="line">        <span class="comment">//keep compact section sorted by start</span></span><br><span class="line">        <span class="keyword">for</span> x &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//插入排序，保证start有序</span></span><br><span class="line">            <span class="keyword">if</span> cm.list[x<span class="number">-1</span>].start &gt; cm.list[x].start &#123;</span><br><span class="line">                cm.list[x<span class="number">-1</span>], cm.list[x] = cm.list[x], cm.list[x<span class="number">-1</span>]</span><br><span class="line">                x = x - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cm.list[x].Set(key, offset, size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p><strong>Note:</strong> <del>感觉这里存在一个bug, 因为二分搜索的时候是根据start来查找能够插入的section， 但是存在一种情况，比如假设list[i].start &lt;= key, 且list[i+1].start &gt; key， 那么上面的程序就会返回插入到第i个section, 但是可能list[i].end &lt; key， 也就是说实际上这个时候应该生成一个新的setction插入到除以i和i+1之间。当然作者假设key是递增的（并不一定要连续），如果key是递增的，这样就能能够保证不会出现出现插入一个中间断节的list.但是如果假设是递增的，何必使用二分查找合适的section呢？肯定是最后一个或者需要重新在后面追加一个，所以目前感觉这个逻辑还是有问题的。考虑的非递增的情况，但是非递增的情况下，在二分查找section又没有考虑断节的情况，所以这里应该有问题，二分查找的代码里21-23行是我添加的，应该可以解决这个bug。后分析发现，因为插入除了最后一个section时候，同样也更新了end所以就不存在这个问题</del></p></blockquote><h3 id="CompactSectionMap"><a href="#CompactSectionMap" class="headerlink" title="CompactSectionMap"></a>CompactSectionMap</h3><p>前面已经简单的介绍了CompactSectionMap的结构，主要有一个数组和一个map组成，并且每个section的数组都有一个容量，下面主要分析怎么set和get一个needleValue。<br>下面是set的核心代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return old entry size</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CompactSection)</span> <span class="title">Set</span><span class="params">(key Key, offset, size <span class="keyword">uint32</span>)</span> <span class="params">(oldOffset, oldSize <span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line">    cs.Lock()</span><br><span class="line">    <span class="keyword">if</span> key &gt; cs.end &#123;</span><br><span class="line">        cs.end = key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i := cs.binarySearchValues(key); i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        oldOffset, oldSize = cs.values[i].Offset, cs.values[i].Size</span><br><span class="line">        <span class="comment">//println("key", key, "old size", ret)</span></span><br><span class="line">        cs.values[i].Offset, cs.values[i].Size = offset, size</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        needOverflow := cs.counter &gt;= batch</span><br><span class="line">        needOverflow = needOverflow || cs.counter &gt; <span class="number">0</span> &amp;&amp; cs.values[cs.counter<span class="number">-1</span>].Key &gt; key</span><br><span class="line">        <span class="keyword">if</span> needOverflow &#123;</span><br><span class="line">            <span class="comment">//println("start", cs.start, "counter", cs.counter, "key", key)</span></span><br><span class="line">            <span class="keyword">if</span> oldValue, found := cs.overflow[key]; found &#123;</span><br><span class="line">                oldOffset, oldSize = oldValue.Offset, oldValue.Size</span><br><span class="line">            &#125;</span><br><span class="line">            cs.overflow[key] = NeedleValue&#123;Key: key, Offset: offset, Size: size&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p := &amp;cs.values[cs.counter]</span><br><span class="line">            p.Key, p.Offset, p.Size = key, offset, size</span><br><span class="line">            <span class="comment">//println("added index", cs.counter, "key", key, cs.values[cs.counter].Key)</span></span><br><span class="line">            cs.counter++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cs.Unlock()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面是set的过程：</p><ul><li>在插入前，首先会进行加锁的操作</li><li>然后如果当前的key大于end, 那么更新end(这里优于，在执行set之前，compactMap的set里有个判断，如果key大于最后一个section时，如果小于当前容量，则直接返回最后一个section，如果大于当前容量，那么要求要小于最后一个sectiond的end, 这样的结果就是最后一个section的end只有在小于当前容量的时候才会更新。低于其他的section就没有这个限制，这样可以防止中间出现断节从而需要插入新的section)</li><li>使用二分查找在values数组中查找是否含有该key, 如果含有那么就更新对应的needleValue，返回旧的needleValue</li><li>如果没有找到，则判断是否需要插入到overflow map中，这里判断是否需要插入到溢出map中并不单单，根据overflow来判断，还有一种情况是，没有大于数组的容量，但是该key小于values数组中最后一个needleValue的key, 这样能够保证values数组的key是有序的</li><li>如果不需要溢出，那么久直接追加在values数组的最后面</li></ul><p>从compactSectionMap中获取一个needleValue的操作比较简单，下面是核心代码：<br></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cs *CompactSection)</span> <span class="title">Get</span><span class="params">(key Key)</span> <span class="params">(*NeedleValue, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    cs.RLock()</span><br><span class="line">    <span class="keyword">if</span> v, ok := cs.overflow[key]; ok &#123;</span><br><span class="line">        cs.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> &amp;v, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> i := cs.binarySearchValues(key); i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        cs.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> &amp;cs.values[i], <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    cs.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>get的时候也同样要先加锁，然后先判断overflow map中 是否存在改key, 如果不存在二分搜索values数组，如果都不存在，则返回没有找到即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个CompactMap的设计思路还是比较清晰的，很像skiplist，通过分段(section)，可以大大的加快查找速度，不过如果key比较随机，那么就会带来很多的二分查找，插入排序的操作，性能就不是那么理想，不过总的来说这个数据结构还是比较高效的。</p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>