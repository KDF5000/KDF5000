<html><head><meta name="generator" content="Hexo 3.9.0"><title>分布式对象存储系统SeaweedFS</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">分布式对象存储系统SeaweedFS</h2><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#相关术语"><span class="toc-text">相关术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Save-File-Id"><span class="toc-text">Save File Id</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteFile"><span class="toc-text">WriteFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadFile"><span class="toc-text">ReadFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#架构"><span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#读写文件"><span class="toc-text">读写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication"><span class="toc-text">Replication</span></a></li></ol></li></ol><p>SeaweedFS是Facebook的海量图片存储系统Haystack的一个开源实现，其目标是：</p><ul><li>存储数亿张图片</li><li>快速响应的文件服务</li></ul><p>seaweedfs提供一个Key-&gt; file的k/v服务，不支持POSIX的文件语义。虽然是Haystack的开源实现，但是也有所不同，比如Haystack论文里提到的使用一个中心节点保存所以文件的metadate。Seaweedfs实现中，中心master是负责文件卷标的管理，具体文件的metadata有相应的valume服务器负责。这样可以大大减缓中心节点的并发的压力，并且提供了快速的文件访问<strong>(一次磁盘操作)</strong>。<br><a id="more"></a><br><strong>每个文件的metadata只有50个字节，因此可以在O(1)的时间内从磁盘读取出来。</strong></p><p>额外的功能:</p><ul><li>可以选择不同层次的副本策略：不备份，不同机架，不同数据中心</li><li>中心节点自动故障恢复 - 无单点问题</li><li>根据文件mime类型自动选择Gzip压缩</li><li>更新或者删除文件之后自动compaction</li><li>同一个集群的服务器可以有不同的磁盘大小，操作系统，文件系统</li><li>增加或者移除节点不会导致任何数据的re-balance</li><li>可选的Filer Server提供”normal”的目录和文件服务</li><li>可选的文件方向调整修复</li><li>支持Etag, Accept-Range, Last-Modified等</li><li>支持in-memory/leveldb/boltdb/btree 模式，以便调整性能/内存的平衡</li></ul><h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><h3 id="Save-File-Id"><a href="#Save-File-Id" class="headerlink" title="Save File Id"></a>Save File Id</h3><p>fid的格式是<code>volumeId, filekey+fileCookie</code>, 其中volumeId是一个32位的无符号整数。fileKey是一个64位的无符号整数。fileCookie是一个64位的无符号整数，用来防止url暴力破解。volumeID, fileKey和fileCookie被编码成十六进制，<strong>获得的fid需要保存到应用服务器</strong>。</p><h3 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h3><p>写文件分为两步：</p><ul><li>从master获取可以保存的volume信息<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:9333/dir/assign</span><br></pre></td></tr></table></figure></li></ul><p>可以返回volume node的相关信息，以及相应的fid<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"fid":"11,026bfba733","url":"127.0.0.1:8080","publicUrl":"127.0.0.1:8080","count":1&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>保存文件到相应的volume server<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -F file=@/Users/KDF5000/Documents/2017/Coding/ObjectStorage/SeaweedFS/seaweedfs/weed/vim-key.png http://127.0.0.1:8080/11,026bfba733</span><br></pre></td></tr></table></figure></li></ul><p>成功的话返回上传的文件名和文件大小<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;vim-key.png&quot;,&quot;size&quot;:236702&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h3><p>读文件可以根据fid到任何一个节点(master,volumeserver)去读，他会自动的跳转到实际存储的节点。<br>请求的格式可以至此下面的几种格式：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/3/01637037d6/my_preferred_name.jpg</span><br><span class="line">http://localhost:8080/3/01637037d6.jpg</span><br><span class="line">http://localhost:8080/3,01637037d6.jpg</span><br><span class="line">http://localhost:8080/3/01637037d6</span><br><span class="line">http://localhost:8080/3,01637037d6</span><br></pre></td></tr></table></figure><p></p><p>也可以对图片进行伸缩<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200</span><br><span class="line">http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fit</span><br><span class="line">http://localhost:8080/3/01637037d6.jpg?height=200&amp;width=200&amp;mode=fill</span><br></pre></td></tr></table></figure><p></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>seaweedfs主要有两种服务类型，master server和volume server。</p><p>master server可以部署多个节点，使用raft维护一致性，主要负责记录volumeId到volume server的映射关系。</p><p>Volume server 是主要的存储节点，有一系列的volume文件(默认32G),每个volume存储很多的小文件，与之对应还有有一个所以文件，记录volume中文件的编号，偏移，大小等信息。Volume server维护本地所有volume的元信息，初始化后保存在内存中，这样当读一个文件的时候只用一次磁盘操作即读出文件的实际内容。</p><h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p>写文件的时候需要首先与master server通信，获得可以保存文件的volume信息，master server会返回(volume id, file key, file cookie, volume node url)格式的信息用于保存文件。然后client在请求返回的volume node url以及文件路径保存文件到volume server。</p><p>读文件时候client可以根据之前记录的volume server信息，根据(volumeId, file key, file cookie)直接读取文件信息，也可以向master节点查询volume server的url, 然后去读取文件信息。</p><h3 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h3><p>在上传图片的时候，获取fid时候可以指定是否需要保存副本，保存的类型是什么<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://localhost:9333/dir/assign?replication=001</span><br></pre></td></tr></table></figure><p></p><p>seaweedfs一共有6种副本类型：</p><ul><li>000: 没有副本(默认)</li><li>001: 在同一个机架保存一份副本</li><li>010: 在同一个数据中心的不同机架保存一份副本</li><li>100：在不同数据中心保存一份副本</li><li>200：在两个不同的数据中心保存两个副本</li><li>110：一个副本在不同机架，一个在不同数据中心</li></ul><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>