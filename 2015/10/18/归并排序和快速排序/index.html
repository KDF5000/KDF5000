<html><head><meta name="generator" content="Hexo 3.9.0"><title>归并排序和快速排序比较</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">归并排序和快速排序比较</h2><p>####1 . 归并排序和快速排序</p><p>#####1.1 归并排序<br>归并排序的思想就是讲数组分为两部分然后对两部分进行排序,然后讲排序后的两部分进行合并,主要的难度在于合并部分,合并的时候需要重新开一个临时数组保存合并的结果,然后再复制到原数组.<br>下面是归并排序的<code>python</code>实现<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># coding:utf-8</span><br><span class="line">__author__ = &apos;devin&apos;</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">data: array</span><br><span class="line">low,high: index of array</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def merge_sort(data, low, high):</span><br><span class="line">    if low &lt; high:</span><br><span class="line">        mid = (low + high)/2</span><br><span class="line">        merge_sort(data, low, mid)</span><br><span class="line">        merge_sort(data, mid+1, high)</span><br><span class="line">        merge(data, low, mid, high)</span><br><span class="line"></span><br><span class="line">def merge(data, low, mid, high):</span><br><span class="line">    temp = []</span><br><span class="line">    i = low</span><br><span class="line">    j = mid+1</span><br><span class="line">    while i &lt;= mid and j &lt;= high:</span><br><span class="line">        if data[i] &lt;= data[j]:</span><br><span class="line">            temp.append(data[i])</span><br><span class="line">            i += 1</span><br><span class="line">        else:</span><br><span class="line">            temp.append(data[j])</span><br><span class="line">            j += 1</span><br><span class="line">    if i &gt; mid:</span><br><span class="line">        while j &lt;= high:</span><br><span class="line">            temp.append(data[j])</span><br><span class="line">            j += 1</span><br><span class="line">    else:</span><br><span class="line">        while i &lt;= mid:</span><br><span class="line">            temp.append(data[i])</span><br><span class="line">            i += 1</span><br><span class="line"></span><br><span class="line">    i = low</span><br><span class="line">    j = 0</span><br><span class="line">    while i &lt;= high:</span><br><span class="line">        data[i] = temp[j]</span><br><span class="line">        i += 1</span><br><span class="line">        j += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    data = [1, 3, 2, 6, 3, 7, 2, 12, 15, 11, 10, 131, 1]</span><br><span class="line">    merge_sort(data, 0, len(data) - 1)</span><br><span class="line">    print data</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>#####1.1 基于链表的归并排序<br>基于链表的归并排序与一般使用的归并排序算法不同之处主要在于使用链表保存原数组元素的索引,开辟空间对索引排序,不改变原数组元素的顺序.该算法使用数组构造链表,排序后返回链表头索引值,也是原数组第一个元素的索引.这样相比普通的归并排序效率要好一些,省去了复制数组的麻烦,在大规模数据的情况下可以提高一定的性能.<br>下面是算法示例,使用<code>python</code>实现.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">__author__ = &apos;devin&apos;</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class MergeSortLink(object):</span><br><span class="line">    def __init__(self, data, link):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.link = link</span><br><span class="line"></span><br><span class="line">    def insert_sort(self, low, high):</span><br><span class="line">        if low == high:</span><br><span class="line">            return low</span><br><span class="line">        head = low</span><br><span class="line">        i = low + 1</span><br><span class="line">        while i &lt;= high:</span><br><span class="line">            temp = self.data[i]</span><br><span class="line">            p = head</span><br><span class="line">            pre = p</span><br><span class="line">            while p != -1:</span><br><span class="line">                if temp &gt;= self.data[p]:</span><br><span class="line">                    pre = p</span><br><span class="line">                    p = self.link[p]</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            if p == -1:  # 插入尾部</span><br><span class="line">                self.link[pre] = i</span><br><span class="line">                self.link[i] = -1</span><br><span class="line">            elif p == head:  # 插入头部</span><br><span class="line">                self.link[i] = p</span><br><span class="line">                head = i</span><br><span class="line">            else:  # 插入中间</span><br><span class="line">                self.link[pre] = i</span><br><span class="line">                self.link[i] = p</span><br><span class="line">            i += 1</span><br><span class="line">        return head</span><br><span class="line"></span><br><span class="line">    def merge_sort_link(self, low, high):</span><br><span class="line">        if high-low + 1 &lt; 16:</span><br><span class="line">            return self.insert_sort(low, high)</span><br><span class="line">        # if low == high:</span><br><span class="line">        #     return low</span><br><span class="line">        else:</span><br><span class="line">            mid = (low+high)/2</span><br><span class="line">            q = self.merge_sort_link(low, mid)</span><br><span class="line">            r = self.merge_sort_link(mid+1, high)</span><br><span class="line">            return self.merge(q, r)</span><br><span class="line"></span><br><span class="line">    def merge(self, q, r):</span><br><span class="line">        i = q</span><br><span class="line">        j = r</span><br><span class="line">        p = None</span><br><span class="line">        k = 0</span><br><span class="line">        while True:</span><br><span class="line">            if self.data[i] &lt;= self.data[j]:</span><br><span class="line">                if p is None:</span><br><span class="line">                    p = i</span><br><span class="line">                else:</span><br><span class="line">                    self.link[k] = i</span><br><span class="line">                k = i</span><br><span class="line">                i = self.link[i]</span><br><span class="line">            else:</span><br><span class="line">                if p is None:</span><br><span class="line">                    p = j</span><br><span class="line">                else:</span><br><span class="line">                    self.link[k] = j</span><br><span class="line">                k = j</span><br><span class="line">                j = self.link[j]</span><br><span class="line">            if i == -1 or j == -1:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">        if i == -1:</span><br><span class="line">            self.link[k] = j</span><br><span class="line">        else:</span><br><span class="line">            self.link[k] = i</span><br><span class="line">        return p</span><br><span class="line"></span><br><span class="line">    def print_link(self, p):</span><br><span class="line">        sorted_data = []</span><br><span class="line">        while p != -1:</span><br><span class="line">            sorted_data.append(self.data[p])</span><br><span class="line">            p = self.link[p]</span><br><span class="line">        print sorted_data</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test_data = [random.randint(1, 100) for i in range(50)]</span><br><span class="line">    print test_data</span><br><span class="line">    link = [-1 for i in range(len(test_data))]  # -1表示链表结束,为了与索引0区分,所以不能用0</span><br><span class="line">    sort_link = MergeSortLink(test_data, link)</span><br><span class="line">    p = sort_link.merge_sort_link(0, len(test_data)-1)</span><br><span class="line">    sort_link.print_link(p)</span><br></pre></td></tr></table></figure><p></p><p>#####1.2 快速排序<br>快速排序的思想很简单,在数组中选择一个数,将数组划分为小于和大于该数两个部分,然后在这两个部分进行递归快速排序,因此算法的核心就是划分数的选择.<br>下面示例代码使用<code>python</code>实现.<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">__author__ = &apos;devin&apos;</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def partition(data, low, high):</span><br><span class="line">    index = random.randint(low, high)</span><br><span class="line">    temp = data[index]</span><br><span class="line">    data[index] = data[low]</span><br><span class="line">    data[low] = temp</span><br><span class="line">    i = low</span><br><span class="line">    j = high</span><br><span class="line">    v = data[low]</span><br><span class="line">    while True:</span><br><span class="line">        while i &lt;= high and data[i] &lt;= v:</span><br><span class="line">            i += 1</span><br><span class="line">        while j &gt;= low and data[j] &gt; v:</span><br><span class="line">            j -= 1</span><br><span class="line">        if i &lt; j:</span><br><span class="line">            temp = data[i]</span><br><span class="line">            data[i] = data[j]</span><br><span class="line">            data[j] = temp</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    data[low] = data[j]</span><br><span class="line">    data[j] = v</span><br><span class="line">    return j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def quick_sort(data, low, high):</span><br><span class="line">    if low &lt; high:</span><br><span class="line">        p = partition(data, low, high)</span><br><span class="line">        quick_sort(data, low, p-1)</span><br><span class="line">        quick_sort(data, p+1, high)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    test_data = [random.randint(1, 100) for i in range(40)]</span><br><span class="line">    print test_data</span><br><span class="line">    quick_sort(test_data, 0, len(test_data)-1)</span><br><span class="line">    print test_data</span><br></pre></td></tr></table></figure><p></p><p>####2 算法测试<br>使用长读分别为100,200,300,400,500,600,700,800,900,1000的是个数组排列统计第一节中两个算法的时间复杂度</p><p>#####2.1 编写测试程序<br>为了方便测试,编写一个测试程序,程序的输入为数据规模因子,比如输入100,则测试的10个数组每个数组为<strong>i*100</strong>,即100,200,300,400,500,600,700,800,900,1000.然后用<code>python</code>的图形库<code>matplotlib</code>输出三个算法的时间-规模折线图.<br>测试代码如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># coding: utf-8</span><br><span class="line">__author__ = &apos;devin&apos;</span><br><span class="line">import time</span><br><span class="line">import random</span><br><span class="line">from MergeSort import merge_sort</span><br><span class="line">from MergeSortL import MergeSortLink</span><br><span class="line">from QuickSort import quick_sort</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    factor = raw_input()</span><br><span class="line">    data_scale = [i * int(factor) for i in range(1, 11)]</span><br><span class="line">    merge_sort_time = []</span><br><span class="line">    merge_sort_l_time = []</span><br><span class="line">    quick_sort_time = []</span><br><span class="line">    print data_scale</span><br><span class="line">    for i in range(10):</span><br><span class="line">        scale = data_scale[i]</span><br><span class="line">        test_data = [random.randint(1, scale*2) for i in range(scale)]</span><br><span class="line"></span><br><span class="line">        data_1 = test_data</span><br><span class="line">        start = time.time()</span><br><span class="line">        merge_sort(data_1, 0, len(data_1) - 1)</span><br><span class="line">        end = time.time()</span><br><span class="line">        merge_sort_time.append(end-start)</span><br><span class="line"></span><br><span class="line">        data_2 = test_data</span><br><span class="line">        link = [-1 for i in range(len(data_2))]  # -1表示链表结束,为了与索引0区分,所以不能用0</span><br><span class="line">        start = time.time()</span><br><span class="line">        sort_link = MergeSortLink(test_data, link)</span><br><span class="line">        p = sort_link.merge_sort_link(0, len(data_2)-1)</span><br><span class="line">        end = time.time()</span><br><span class="line">        # sort_link.print_link(p)</span><br><span class="line">        merge_sort_l_time.append(end-start)</span><br><span class="line"></span><br><span class="line">        data_3 = test_data</span><br><span class="line">        start = time.time()</span><br><span class="line">        quick_sort(data_3, 0, len(data_3) - 1)</span><br><span class="line">        end = time.time()</span><br><span class="line">        # print data_3</span><br><span class="line">        quick_sort_time.append(end-start)</span><br><span class="line"></span><br><span class="line">    print &quot;Scale: &quot;, data_scale</span><br><span class="line">    print &quot;Merge: &quot;, merge_sort_time</span><br><span class="line">    print &quot;MergeL: &quot;, merge_sort_l_time</span><br><span class="line">    print &quot;QuickSort: &quot;, quick_sort_time</span><br><span class="line"></span><br><span class="line">    merge_sort_plot = plt.plot(data_scale, merge_sort_time, &apos;b&apos;, label=&apos;MergeSort&apos;)</span><br><span class="line">    merge_sort_l_plot = plt.plot(data_scale, merge_sort_l_time, &apos;r&apos;, label=&apos;MergeSortLink&apos;)</span><br><span class="line">    quick_sort_plot = plt.plot(data_scale, quick_sort_time, &apos;g&apos;, label=&apos;QuickSort&apos;)</span><br><span class="line"></span><br><span class="line">    quick_sort_plot = plt.plot(data_scale,</span><br><span class="line">                               [quick_sort_time[0]*data_scale[i]/data_scale[0] for i in range(10)],</span><br><span class="line">                               &apos;y&apos;, label=&apos;O(n)&apos;)</span><br><span class="line">    max_time = max(merge_sort_time[9], merge_sort_l_time[9], quick_sort_time[9])</span><br><span class="line">    plt.xlabel(&quot;Scale&quot;)</span><br><span class="line">    plt.ylabel(&quot;time&quot;)</span><br><span class="line">    plt.ylim(0, max_time * 1.2)</span><br><span class="line">    plt.title(&apos;Algorithm Time &amp; Data Scale&apos;)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p></p><p>#####2.2 测试分析<br>由于再规模因为为100时,运行时间很短,因此测试因子选择10000,测试结果如下图所示<br><img src="/images/archive/img_cmd.png" alt><br><img src="/images/archive/img_res.png" alt><br>在折线图中,黄色实线代表时间复杂度为O(n), 蓝色是普通的归并排序,红色是基于链表的归并排序,绿色是快速排序,可以清楚的看到三种排序算法的时间复杂度明显大于O(n), 小于$O(n^2)$, 而且再数据规模较小的情况下,三者的排序所用时间差不多,数据规模较大是,快速排序和基于链表的归并排序明显优于普通的归并排序,快速排序效果最好,因此再大规模数据下快速排序的速度最快,他们的时间复杂度均为 $O(nlogn)$</p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>