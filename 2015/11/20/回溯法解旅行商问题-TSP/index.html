<html><head><meta name="generator" content="Hexo 3.9.0"><title>回溯法解旅行商问题(TSP)</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">回溯法解旅行商问题(TSP)</h2><blockquote><p>旅行商问题,常被成为旅行推销员问题,是指一名推销员要拜访多个地点,如何找到再拜访每个地点一次后再回到起点的最短路径.</p></blockquote><p>进一步的抽象,可以转化为图论的问题,将每个城市看成图$G(V,E)$中的一个顶点,则旅行商问题可以转化为从一个顶点s出发,找到一条最短的路径从s出发,经过所有的顶点,最后回到s.最简单的解法就是枚举,枚举所有的路径,计算其每条路径的长度,取最短的即可.枚举最有的路径则其有$(n-1)!$条路径,如果n非常大,则解的空间将非常大,我们可以使用一个棵树,那么这棵树将非常庞大.</p><p>既然我们可以用一个树表示类似问题的所有可能解,那么现在的问题就变成了从解空间树中找到最短的路径,也就是树的搜索问题,搜索每一条路,找到最短的路径.但是再进一步思考一下,其实很多分枝,我们在没有搜索到叶子节点的时候就可以通过一些已知的条件就可以判断这条路不可能是最短的路.回溯法就是这个思路,按照深度优先的策略搜索解空间树,通过一些约束条件或者边界条件判断是否继续搜索下去,如果不满足约束条件则直接返回.</p><a id="more"></a><p>因此回溯法求解问题的过程大致如下:</p><blockquote></blockquote><ul><li>确定问题的解空间(用树表示)</li><li>确定问题的约束条件和边界条件</li><li>深度优先搜索解空间幷根据约束条件和边界条件进行裁剪</li></ul><p>再一次的回到旅行商问题(TSP),以此为例看一下回溯法的解题过程</p><p>####确定解空间<br>假设有四个城市A,B,C,D, 从A出发,求经过所有顶点后回到A的最短路径,我们用树表示所有的解,前面已经说过是一个$(n-1)!$排列树,如下图所示:</p><p><img src="/images/archive/img_tsp.png" alt></p><p>####确定约束条件和边界条件<br>假设用cl表示从A出发到当前节点的的路径长度,fl表示当前最短的环路长度.k表示路径中第k个节点,$x_k$表示第k个点选择的城市编号(A-D编号为1-4),w为邻接矩阵.<br>则当k&lt;n时,如果$x_k$添加到当前路径已经比当前最优路径大,则不用继续搜索,因此约束条件可以表示为:<br>$$cl+w[x_{k-1},x_k] &lt;= fl$$<br>当k=n时,也就是叶子节点,如果该回路比当前最优回路短,则此条回路比之前更好,即<br>若<br>$$cl+w[x_{k-1},x_k] + w[x_k,1] &lt; fl$$<br>则更新fl(如果需要记录最有路径,还要更新记录)<br>$$fl = cl+w[x_{k-1},x_k] + w[x_k,1]$$</p><p>上面便是约束条件和边界条件</p><p>####深度优先搜索和剪枝<br>搜索的问题就比较简单了,按照DFS的思路搜索就行了,当然特定的问题可以进行一些优化.然后搜索的过程使用约束条件的边界条件进行剪枝和更新最有路径.</p><p>下面是伪代码:<br><img src="/images/archive/img_tsp_pseudocode.png" alt></p><p>用java实现如下所示<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断第k个数是否不同与前k-1个数</span><br><span class="line"> * @param k</span><br><span class="line"> * @return bool</span><br><span class="line"> */</span><br><span class="line">private boolean nextValue(int k)&#123;</span><br><span class="line">    int i = 0;</span><br><span class="line">    while(i &lt; k)&#123;</span><br><span class="line">        if(x[k] == x[i])&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        i += 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 第k条路径选择</span><br><span class="line"> * @param k</span><br><span class="line"> */</span><br><span class="line">private void backUp(int k)&#123;</span><br><span class="line">    if(k==N-1)&#123;</span><br><span class="line">        for (int j=1;j&lt;=N;j++)&#123;</span><br><span class="line">            x[k] = Math.floorMod(x[k]+1, N);</span><br><span class="line">            if(nextValue(k) &amp;&amp; cl + weight[x[k-1]][x[k]] + weight[x[k]][0] &lt; fl) &#123;//如果最短路径,更新最优解</span><br><span class="line">                fl = cl + weight[x[k - 1]][x[k]] + weight[x[k]][0];</span><br><span class="line">                for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">                    bestX[i] = x[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        for(int j=1; j&lt;=N; j++)&#123;</span><br><span class="line">            x[k] = Math.floorMod(x[k]+1, N);</span><br><span class="line">            if(nextValue(k) &amp;&amp; cl+weight[x[k-1]][x[k]] &lt;= fl)&#123;</span><br><span class="line">                //此路可行</span><br><span class="line">                cl += weight[x[k-1]][x[k]];</span><br><span class="line">                backUp(k+1);</span><br><span class="line">                cl -= weight[x[k-1]][x[k]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void solve()&#123;</span><br><span class="line">    int k = 1; //第0个顶点是固定的,从第一个顶点开始选择</span><br><span class="line">    cl = 0;</span><br><span class="line">    fl = Integer.MAX_VALUE;</span><br><span class="line">    backUp(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>完整代码下载见:<a href="https://github.com/KDF5000/LeetCode/blob/master/java/BackTSP.java" target="_blank" rel="noopener">TSP回溯法</a></p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>