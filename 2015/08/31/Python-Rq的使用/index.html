<html><head><meta name="generator" content="Hexo 3.9.0"><title>Python Rq的使用</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">Python Rq的使用</h2><p><code>Rq</code>的介绍和安装可以参考<a href="http://kdf5000.github.io/2015/08/23/Ubuntu-14-04-%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Python-rq%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">Ubuntu 14.04 下安装使用Python rq模块</a>，此文章详细的介绍了安装<code>Rq</code>的全部过程，文章最后给出了<code>Rq</code>官方文档的地址。</p><p> <code>Rq</code>官方文档详细的介绍了<code>Queues</code>, <code>Workers</code>，<code>Results Jobs</code>等每个组件的功能和使用，但是并没有指出这几个组件之间到底有什么关系，如果联合起来使用，对于像我这种菜鸟级的码农，一开始还真有点摸不着头脑，思考一番，懂了之后才发现原来是那么的简单…下面是我自己对<code>Rq</code>的整体认识图（windows 画图画的有点粗糙望见谅）</p><p><img src="/images/archive/img_rq_model.png" alt></p><p>用白话解释就是：有一个大工厂，这个工厂有个大仓库（Redis），有一个或者几个管理员（CreateJob），一些工人(Worker)。管理员负责产生任务，把任务放到仓库里特定的位置（特定的Queue），然后工人自己去队列去任务，默默的完成任务，完成成功后按照要求放到特定的位置（可能是仓库也可能是其他地方）。如果任务比较多或者想在短期内完成任务，那么工厂就可以招聘更多的工人去完成这些任务。</p><p>使用<code>Rq</code>模块最简单的就是只需要一个管理员，一个仓库，一个工人（工人都是一样的，可以复制很多出来）</p><p>####建仓库<br>仓库就是我们安装的时候使用的redis，具体建造过程参见<a href="http://kdf5000.github.io/2015/08/23/Ubuntu-14-04-%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8Python-rq%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">Ubuntu 14.04 下安装使用Python rq模块</a>中安装<code>Redis</code>一节</p><a id="more"></a><p>####招管理员<br>仓库建好后，我们就需要一个或者几个管理员来生成不同的任务（Job），放到仓库里即可，<code>Job</code>的调度不用担心，<code>Rq</code>模块会自己处理，其实就是不同的工人自发的从仓库里特定的区域拿任务即可。<br>一个管理员的主要任务就是产生任务，如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#连接redis</span><br><span class="line">redis_conn = Redis(host=&apos;192.168.0.108&apos;, port=6379)</span><br><span class="line">q = Queue(connection=redis_conn, async=True)  # 设置async为False则入队后会自己执行 不用调用perform</span><br><span class="line"></span><br><span class="line">with open(&quot;companies.json&quot;, &apos;r&apos;) as f:</span><br><span class="line">    i = 0</span><br><span class="line">    for line in f:</span><br><span class="line">        job = q.enqueue(parse_company, line.strip())</span><br><span class="line">        i += 1</span><br><span class="line">        print i, &quot;:&quot;, job.id</span><br></pre></td></tr></table></figure><p></p><p>这个管理员的工作就是从文件<code>Companies.json</code>读取每一行内容，将每一行内容放到仓库(Redis)默认的位置（Queue），并且指定那一类的<code>worker</code>去完成这些任务，也就是<code>parse_company</code>，其实只是指定工人所要做的工作流程，并不是一个工人实体。<code>parse_company</code>的流程如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def parse_company(json_data):</span><br><span class="line">    try:</span><br><span class="line">        obj = json.loads(json_data)</span><br><span class="line">        company_data = obj[&apos;Company&apos;]</span><br><span class="line">        new_company_id = insert_company_info(company_data)  #插入公司数据到数据库</span><br><span class="line">        if new_company_id is None:</span><br><span class="line">            conn.rollback()</span><br><span class="line">            with open(&apos;error.txt&apos;, &apos;a&apos;) as ferr:</span><br><span class="line">                ferr.write(json_data)</span><br><span class="line">            return None</span><br><span class="line">        # 股东结构</span><br><span class="line">        partners = company_data[&apos;Partners&apos;]</span><br><span class="line">        for val in partners:</span><br><span class="line">            id = insert_parter_info(new_company_id, val)  #插入股东信息到数据库</span><br><span class="line">            if id is None:</span><br><span class="line">                cursor.close()</span><br><span class="line">                conn.rollback()</span><br><span class="line">                conn.close()</span><br><span class="line">                with open(&apos;error.txt&apos;, &apos;a&apos;) as ferr:</span><br><span class="line">                    ferr.write(json_data)</span><br><span class="line">                return None</span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.commit()</span><br><span class="line">        conn.close()</span><br><span class="line">        print &apos;success!&apos;</span><br><span class="line">        with open(&apos;success.txt&apos;, &apos;a&apos;) as fsu:</span><br><span class="line">            fsu.write(json_data)</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure><p></p><p>负责这个任务的工人所要做的工作也比较简单，就是解析每个任务内容（一行json文本），然后插入到数据库中。</p><p>其实管理员的工作还是比较繁重的，既要将大的任务分解成小的任务，又要指定那一类工人（那个工艺流程）去做这些事，这也正是管理员工资比工人工资高的地方吧，虽然不出体力，但是脑力劳动还是比较强的。</p><p>####招聘工人<br>招聘工人其实比较简单了，当然需要付出的，在计算机世界就是要么多买一些计算机或者多开几个线程，然后还是培训这些工人，告诉他们负责那个工艺流程。</p><p>将上一节中指定的工艺流程的文件拷贝一份，放到需要完成任务的计算机上，当然在该计算机也要安装<code>Rq</code>模块，到此时一个工人的培训已经结束了（有点填鸭式教育的感觉），让工人开始工作只要一个指令即可。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在parse_company文件所在目录下执行</span><br><span class="line">$rqworker -u &quot;redis://192.168.0.108:6379&quot;  #-u后面的地址是仓库（redis）的地址</span><br></pre></td></tr></table></figure><p></p><p>这个指令需要告诉工人去哪个仓库取任务，就这么简单，想要招几个工人就招几个工人</p><p>####验收产品<br>每个工人都是按照特定的工艺流程进行的，每个工艺流程指定了产品的输出位置，到相应的位置验收产品即可。</p><p>整个工厂的工艺流程见<a href="https://github.com/KDF5000/ParseCompany" target="_blank" rel="noopener">这里</a></p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>