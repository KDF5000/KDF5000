<html><head><meta name="generator" content="Hexo 3.9.0"><title>PHP与Redis的仿Twitter实例</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">PHP与Redis的仿Twitter实例</h2><p>译者注：<br>原文位于Redis官网<a href="http://redis.io/topics/twitter-clone" target="_blank" rel="noopener">http://redis.io/topics/twitter-clone</a><br>Redis是NoSQL数据库中一个知名数据库，在新浪微博中亦有部署，适合固定数据量的热数据的访问。<br>作为入门，这是一篇很好的教材，简单描述了如何使用KV数据库进行数据库的设计。新的项目<a href="http://www.xiayucha.com亦采用Redis" target="_blank" rel="noopener">www.xiayucha.com亦采用Redis</a> + MySQL进行开发，考虑Redis文档比较少，故翻译了此文。<br>其他参考资料：</p><p><a href="http://redis.readthedocs.org/en/latest/index.html" target="_blank" rel="noopener">Redis命令参考中文版(Redis Command Reference</a><br><a href="http://try.redis-db.com/" target="_blank" rel="noopener">Try Redis</a></p><p>我会在此文中描述如何使用<code>PHP</code>以及仅使用<code>Redis</code>来设计实现一个简单的<code>Twitter</code>克隆。很多编程社区常认为 <code>KV</code> 储存是一个特别的数据库，在 <code>web</code> 应用中不能替代关系数据库。本文尝试证明这恰恰相反。这个<code>twitter</code>克隆名为<code>Retwis</code>，结构简单，性能优异，能很轻易地用<code>N`</code>个web<code>服务器和</code>Redis`服务器以分布式架构。</p><p>在此获取源码<a href="http://code.google.com/p/redis/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/redis/downloads/list</a><br>我们使用PHP作为例子是因为它能被每个人读懂，也能使用Ruby、Python、Erlang或其他语言获取同样(或者更佳)的效果。</p><p><em>注意</em>：<code>Retwis-RB</code>是一个由<code>Daniel Lucraft</code>用<code>Ruby</code>与<code>Sinatra</code>写的<code>Retwis</code>分支！此文全部代码在本页尾部的<code>Git repository</code>链接里。此文以PHP为例，但是<code>Ruby</code>程序员也能检出其他源码。他们很相似。注意<code>Retwis-J</code>是<code>Retwis</code>的一个分支，由<code>Costin Leau</code>以<code>Java</code>和<code>Spring</code>框架写成。源码能在<code>GitHub</code>找到，并且在<code>springsource.org</code>有综合的文档。</p><a id="more"></a><p>###<code>Key-value</code> 数据库基础<br><code>KV</code>数据的精髓，是能够把<code>value</code>储存在<code>key</code>里，此后该数据仅能够通过确切的<code>key</code>来获取，无法搜索一个值。确切的来讲，它更像一个大型<code>HASH/</code>字典，但它是持久化的，比如，当你的程序终止运行，数据不会消失。比如我们能用<code>SET</code>命令以<code>key foo</code> 来储存值<code>bar</code></p><blockquote></blockquote><p> SET foo bar</p><p><code>Redis</code>会永久储存我们的数据，所以之后我们可以问<code>Redis</code>：“储存在<code>key foo</code>里的数据是什么？”，<code>Redis</code>会返回一个值：<code>bar</code></p><blockquote></blockquote><p> GET foo =&gt; bar</p><p><code>KV</code>数据库提供的其他常见操作有:<code>DEL</code>，用于删除指定的<code>key</code>和关联的<code>value</code>；<br><code>SET-if-not-exists</code> (在<code>Redis</code>上称为<code>SETNX</code>)仅会在<code>key</code>不存在的时候设置一个值；<br><code>INCR</code>能够对指定的<code>key</code>里储存的数字进行自增。</p><blockquote></blockquote><p> SET foo 10<br> INCR foo =&gt; 11<br> INCR foo =&gt; 12<br> INCR foo =&gt; 13</p><p>####原子操作<br>目前为止它是相当简单的，但是<code>INCR</code>有些不同。设想一下，为什么要提供这个操作？毕竟我们自己能用以下简单的命令实现这个功能：</p><blockquote></blockquote><p> x = GET foo<br> x = x + 1<br> SET foo x</p><p>问题在于要使上面的操作正常进行，同时只能有一个客户端操作<code>x</code>的值。看看如果两台电脑同时操作这个值会发生什么：</p><blockquote></blockquote><p> x = GET foo (返回10)<br> y = GET foo (返回10)<br> x = x + 1 (x现在是11)<br> y = y + 1 (y现在是11)<br> SET foo x (foo现在是11)<br> SET foo y (foo现在是11)</p><p>问题发生了！我们增加了值两次，本应该从<code>10</code>变成<code>12</code>，现在却停留在了<code>11</code>。这是因为用<code>GET</code>和<code>SET</code>来实现<code>INCR</code>不是一个原子操作(<code>atomic operation</code>)。所以<code>Redis\memcached</code>之类提供了一个原子的<code>INCR</code>命令，服务器会保护<code>get-increment-set</code>操作，以防止同时的操作。让<code>Redis</code>与众不同的是它提供了更多类似<code>INCR</code>的方案，用于解决模型复杂的问题。因此你可以不使用任何SQL数据库、仅用Redis写一个完整的web应用，而不至于抓狂。</p><p>####超越<code>Ke-Value</code>数据库<br>本节我们会看到构建一个Twitter克隆所需Redis的功能。首先需要知道的是，Redis的值不仅仅可以是字符串(String)。<br>Redis的值可以是列表(Lists)也可以是集合(Sets)，在操作更多类型的值时也是原子的，所以多方操作同一个KEY的值也是安全的。<br>让我们从一个Lists开始：</p><blockquote></blockquote><p> LPUSH mylist a (现在mylist含有一个元素:’a’的list)<br> LPUSH mylist b (现在mylist含有元素’b,a’)<br> LPUSH mylist c (现在mylist含有’c,b,a’)</p><p>LPUSH的意思是Left Push， 就是把一个元素加在列表(list)的左边(或者说头上)。在PUSH操作之前，如果mylist这个键(key)不存在，Redis会自动创建一个空的list。就像你能想到的一样，同样有RPUSH操作可以把元素加在列表(list)的右边(尾部)。这对我们复制一个twitter非常有用，例如我们可以把用户的更新储存在username:updates里。当然，我们也有相应的操作来获取数据或者信息。比如LRANGE返回列表(list)的一个范围内的元素，或者所有元素</p><blockquote><p>LRANGE mylist 0 1 =&gt; c,b</p></blockquote><p>LRANGE使用从零开始的索引(zero-based indexes)，第一个元素的索引是0，第二个是1，以此类推。该命令的参数是：</p><blockquote></blockquote><p>LRANGE key first-index last-index</p><p>参数last index可以是负数，具有特殊的意义：-1是列表(list)的最后一个元素，-2是倒数第二个，以此类推。所以，如果要获取整个list，我们能使用以下命令：</p><blockquote></blockquote><p> LRANGE mylist 0 -1 =&gt; c,b,a</p><p>其他重要的操作有LLEN，返回列表(list)的长度，LTRIM类似于LRANGE，但不仅仅会返回指定范围内的元素，而且还会原子地把列表(list)的值设置这个新的值。我们将会使用这些list操作，但是注意阅读Redis文档来浏览所有redis支持的list操作。</p><p>###数据类型：集合(set)<br>除了列表(list)，Redis还提供了集合(sets)的支持，是不排序(unsorted)的元素集合。<br>它能够添加、删除、检查元素是否存在，并且获取两个结合之间的交集。当然它也能请求获取集合（set）里一个或者多个元素。<br>几个例子可以使概念更为清晰。记住：SADD是往集合(set)里添元素；SREM是从集合(set)里删除元素；SISMEMBER是检测一个元素是否包含在集合里；SINTER用于显示两个集合的交集。<br>其他操作有，SCARD用于获取集合的基数(集合中元素的数量)；SMEMBERS返回集合中所有的元素</p><blockquote></blockquote><p> SADD myset a<br> SADD myset b<br> SADD myset foo<br> SADD myset bar<br> SCARD myset =&gt; 4<br> SMEMBERS myset =&gt; bar,a,foo,b</p><p>注意SMEMBERS不会以我们添加的顺序返回元素，因为集合(Sets)是一个未排序的元素集合。如果你要储存顺序，最好使用列表(Lists)取而代之。以下是基于集合的一些操作：</p><blockquote></blockquote><p> SADD mynewset b<br> SADD mynewset foo<br> SADD mynewset hello<br> SINTER myset mynewset =&gt; foo,b</p><p>SINTER能够返回集合之间的交集，但并不仅限于两个集合(Sets)，你能获取4个、5个甚至1000个集合(sets)的交集。最后，让我们看下SISMEMBER是如何工作的：</p><blockquote></blockquote><p> SISMEMBER myset foo =&gt; 1<br> SISMEMBER myset notamember =&gt; 0</p><p>Okay，我觉得我们可以开始coding啦！</p><p>####先决条件<br>如果你还没下载，请前往<a href="http://code.google.com/p/redis/downloads/list" target="_blank" rel="noopener">http://code.google.com/p/redis/downloads/list</a>下载Retwis的源码。它包含几个PHP文件，是个简单的tar.gz文件。实现的非常简单，你会在里面找到PHP客户端(redis.php)，用于redis与PHP的交互。该库由Ludovico Magnocavallo(<a href="http://qix.it/" target="_blank" rel="noopener">http://qix.it/</a> )编写，你可以在自己的项目中免费使用。但如果要更新库的版本请下载Redis的发行版。(注意:现在有更好的PHP库了，请检查我们的客户端页面<a href="http://redis.io/clients" target="_blank" rel="noopener">http://redis.io/clients</a>)你需要的另一个东西是正常运行的Redis服务器。仅需要获取源码、用make编译、用./redis-server就完工了，点儿也不须配置就可以在你的电脑上运行Retwis。</p><p>###数据结构规划<br> 当使用关系数据库的时候，这一步往往是在设计数据表、索引的表单里处理。我们没有表，那我们设计什么呢？ 我们需要确认物体使用的key以及key采用的类型。</p><p> 让我们从用户这块开始设计。当然了，首先需要展示用户的username, userid, password, followers，自己follow的用户等。第一个问题是：如何在我们的系统中标识一个用户？username是个好主意，因为它是唯一的。不过它太大了，我们想要降低内存的使用。如果我们的数据库是关系数据库，我们能关联唯一ID到每一个用户。每一个对用户的引用都通过ID来关联。做起来很简单，因为我们有我们的原子的INCR命令！当我们创建一个新用户，我们假设这个用户叫”antirez”：</p><blockquote></blockquote><p> INCR global:nextUserId =&gt; 1000<br> SET uid:1000:username antirez<br> SET uid:1000:password p1pp0</p><p>我们使用global:nextUserId为键(Key)是为了给每个新用户分配一个唯一ID，然后用这个唯一ID来加入其他key，以识别保存用户的其他数据。这就是kv数据库的设计模式!请牢记于心，除了已经定义的KEY，我们还需要更多的来完整定义一个用户，比如有时需要通过用户名来获取用户ID，所以我们也需要设置这么一个键(Key)</p><blockquote></blockquote><p> SET username:antirez:uid 1000</p><p>一开始看上去这样很奇怪，但请记住我们只能通过key来获取数据!这不可能告诉Redis返回包含某值的Key，这也是我们的强处。<br>用关系数据库方式来讲，这个新实例强迫我们组织数据，以便于仅使用primary key访问任何数据。</p><p>####关注\被关注与更新<br>这也是在我们系统中另一个重要需求.每个用户都有follower，也有follow的用户.对此我们有最佳的数据结构!那就是…..集合(Sets).那就让我们在结构中加入两个新字段:</p><blockquote></blockquote><p> uid:1000:followers =&gt; Set of uids of all the followers users<br> uid:1000:following =&gt; Set of uids of all the following users</p><p>另一个重要的事情是我们需要有个地方来放用户主页上的更新。这个要以时间顺序排序，最新的排在旧的前面。所以，最佳的类型是列表(List)。<br>基本上每个更新都会被LPUSH到该用户的updates key.多亏了LRANGE，我们能够实现分页等功能。请注意更新(updates)和帖子(posts)讲的是同一个东西，实际上更新(updates)是有点小的帖子(posts)。</p><blockquote></blockquote><p> uid:1000:posts =&gt; a List of post ids, every new post is LPUSHed here.</p><p>####验证<br>OK，除了验证，或多或少我们已经有了关于该用户的一切东西。我们处理验证用一个简单而健壮(鲁棒)的办法:我们不使用PHP的session或者其他类似方式。<br>我们的系统必须是能够在不同不同服务器上分布式部署的，所以一切状态都必须保存在Redis里。所以我们所需要的一个保存在已验证用户cookie里的随机字符串。<br>包含同样随机字符串的一个key告诉我们用户的ID。我们需要使用两个key来保证这个验证机制的健壮性:</p><blockquote></blockquote><p> SET uid:1000:auth fea5e81ac8ca77622bed1c2132a021f9<br> SET auth:fea5e81ac8ca77622bed1c2132a021f9 1000</p><p>为了验证一个用户，我们需要做一些简单的工作(login.php):</p><ul><li>从登录表单获取用户的用户名和密码</li><li>检查是否存在一个键 username:<username>:uid</username></li><li>如果这个user id存在(假设1000)</li><li>检查 uid:1000:password 是否匹配，如果不匹配，显示错误信息</li><li>匹配则设置cookie为字符串”fea5e81ac8ca77622bed1c2132a021f9”(uid:1000:auth的值)<br>实例代码:</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">"retwis.php"</span>);   </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># Form sanity checks   </span></span><br><span class="line"><span class="keyword">if</span> (!gt(<span class="string">"username"</span>) || !gt(<span class="string">"password"</span>))   </span><br><span class="line">    goback(<span class="string">"You need to enter both username and password to login."</span>);   </span><br><span class="line">  </span><br><span class="line"><span class="comment"># The form is OK, check if the username is available   </span></span><br><span class="line">$username = gt(<span class="string">"username"</span>);   </span><br><span class="line">$password = gt(<span class="string">"password"</span>);   </span><br><span class="line">$r = redisLink();   </span><br><span class="line">$userid = $r-&gt;get(<span class="string">"username:$username:id"</span>);   </span><br><span class="line"><span class="keyword">if</span> (!$userid)   </span><br><span class="line"> goback(<span class="string">"Wrong username or password"</span>);   </span><br><span class="line">$realpassword = $r-&gt;get(<span class="string">"uid:$userid:password"</span>);   </span><br><span class="line"><span class="keyword">if</span> ($realpassword != $password)   </span><br><span class="line"> goback(<span class="string">"Wrong useranme or password"</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment"># Username / password OK, set the cookie and redirect to index.php   </span></span><br><span class="line">$authsecret = $r-&gt;get(<span class="string">"uid:$userid:auth"</span>);   </span><br><span class="line">setcookie(<span class="string">"auth"</span>,$authsecret,time()+<span class="number">3600</span>*<span class="number">24</span>*<span class="number">365</span>);   </span><br><span class="line">header(<span class="string">"Location: index.php"</span>);</span><br></pre></td></tr></table></figure><p>每次用户登录都会运行，但我们需要一个函数isLoggedIn用于检验一个用户是否已经验证。<br>这些是isLoggedIn的逻辑步骤</p><ul><li>从用户获取cookie里auth的值。如果没有cookie，该用户未登录。我们称这个cookie为<authcookie></authcookie></li><li>检查auth:<authcookie>是否存在，存在则获取值(例子里是1000)</authcookie></li><li>为了再次确认，检查uid:1000:auth是否匹配</li><li>用户已验证，在全局变量$User中载入一点信息<br>也许代码比描述更短:</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLoggedIn</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">global</span> $User, $_COOKIE;   </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">isset</span>($User)) <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">isset</span>($_COOKIE[<span class="string">'auth'</span>])) &#123;   </span><br><span class="line">         $r = redisLink();   </span><br><span class="line">         $authcookie = $_COOKIE[<span class="string">'auth'</span>];   </span><br><span class="line">         <span class="keyword">if</span> ($userid = $r-&gt;get(<span class="string">"auth:$authcookie"</span>)) &#123;   </span><br><span class="line">              <span class="keyword">if</span> ($r-&gt;get(<span class="string">"uid:$userid:auth"</span>) != $authcookie) <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">              loadUserInfo($userid);   </span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">          &#125;   </span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">  &#125;   </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loadUserInfo</span><span class="params">($userid)</span> </span>&#123;   </span><br><span class="line">      <span class="keyword">global</span> $User;   </span><br><span class="line">    </span><br><span class="line">      $r = redisLink();   </span><br><span class="line">      $User[<span class="string">'id'</span>] = $userid;   </span><br><span class="line">      $User[<span class="string">'username'</span>] = $r-&gt;get(<span class="string">"uid:$userid:username"</span>);   </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>把loadUserInfo作为一个独立函数对于我们的应用而言有点杀鸡用牛刀了，但是对于复杂的应用而言这是一个不错的模板。<br>作为一个完整的验证，还剩下logout还没实现。在logout的时候我们怎么做呢？<br>很简单，仅仅改变uid:1000:auth里的随机字符串，删除旧的auth:<oldauthstring>并增加一个新的auth:<newauthstring><br><em>重要</em> :logout过程解释了为什么我们不仅仅查找auth:<randomstring>而是再次检查了uid:1000:auth。真正的验证字符串是后者，auth:<randomstring>是易变的.<br>假设程序中有BUGs或者脚本被意外中断，那么就有可能有多个auth:<something>指向同一个用户id。<br>logout代码如下:(logout.php)</something></randomstring></randomstring></newauthstring></oldauthstring></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="string">"retwis.php"</span>);   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (!isLoggedIn()) &#123;   </span><br><span class="line">    header(<span class="string">"Location: index.php"</span>);   </span><br><span class="line">    <span class="keyword">exit</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">$r = redisLink();   </span><br><span class="line">$newauthsecret = getrand();   </span><br><span class="line">   $userid = $User[<span class="string">'id'</span>];   </span><br><span class="line">   $oldauthsecret = $r-&gt;get(<span class="string">"uid:$userid:auth"</span>);   </span><br><span class="line">   </span><br><span class="line">   $r-&gt;set(<span class="string">"uid:$userid:auth"</span>,$newauthsecret);   </span><br><span class="line">   $r-&gt;set(<span class="string">"auth:$newauthsecret"</span>,$userid);   </span><br><span class="line">   $r-&gt;delete(<span class="string">"auth:$oldauthsecret"</span>);   </span><br><span class="line">   </span><br><span class="line">   header(<span class="string">"Location: index.php"</span>);</span><br></pre></td></tr></table></figure><p>以上是我们所描述过的，应该比较易于理解。<br>更新(Updates)<br>更新，或者称为帖子(posts)的实现则更为简单。为了在数据库里创建一个新的帖子，我们做了以下工作:<br> INCR global:nextPostId =&gt; 10343<br> SET post:10343 “$owner_id|$time|I’m having fun with Retwis”<br>就像你看到的一样，帖子的用户id和时间直接储存在了字符串里。<br>在这个例子中我们不需要根据时间或者用户id来查找帖子，所以把他们紧凑地挤在一个post字符串里更佳。<br>在新建一个帖子之后，我们获得了帖子的id。需要LPUSH这个帖子的id到每一个follow了作者的用户里去，当然还有作者的帖子列表。<br>update.php这个文件展示了这个工作是如何完成的:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">include</span>(<span class="string">"retwis.php"</span>);   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (!isLoggedIn() || !gt(<span class="string">"status"</span>)) &#123;   </span><br><span class="line">    header(<span class="string">"Location:index.php"</span>);   </span><br><span class="line">    <span class="keyword">exit</span>;   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">$r = redisLink();   </span><br><span class="line">$postid = $r-&gt;incr(<span class="string">"global:nextPostId"</span>);   </span><br><span class="line">   $status = str_replace(<span class="string">"\n"</span>,<span class="string">" "</span>,gt(<span class="string">"status"</span>));   </span><br><span class="line">   $post = $User[<span class="string">'id'</span>].<span class="string">"|"</span>.time().<span class="string">"|"</span>.$status;   </span><br><span class="line">   $r-&gt;set(<span class="string">"post:$postid"</span>,$post);   </span><br><span class="line">   $followers = $r-&gt;smembers(<span class="string">"uid:"</span>.$User[<span class="string">'id'</span>].<span class="string">":followers"</span>);   </span><br><span class="line">   <span class="keyword">if</span> ($followers === <span class="keyword">false</span>) $followers = <span class="keyword">Array</span>();   </span><br><span class="line">   $followers[] = $User[<span class="string">'id'</span>]; <span class="comment">/* Add the post to our own posts too */</span>  </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">foreach</span>($followers <span class="keyword">as</span> $fid) &#123;   </span><br><span class="line">    $r-&gt;push(<span class="string">"uid:$fid:posts"</span>,$postid,<span class="keyword">false</span>);   </span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="comment"># Push the post on the timeline, and trim the timeline to the   </span></span><br><span class="line">   <span class="comment"># newest 1000 elements.   </span></span><br><span class="line">   $r-&gt;push(<span class="string">"global:timeline"</span>,$postid,<span class="keyword">false</span>);   </span><br><span class="line">   $r-&gt;ltrim(<span class="string">"global:timeline"</span>,<span class="number">0</span>,<span class="number">1000</span>);   </span><br><span class="line">   </span><br><span class="line">   header(<span class="string">"Location: index.php"</span>);</span><br></pre></td></tr></table></figure><p>函数的核心是foreach。 通过SMEMBERS获取当前用户的所有follower，然后循环会把帖子(post)LPUSH到每一个用户的 uid:<userid>:posts里<br>注意我们同时维护了一个所有帖子的时间线。为此我们还需要LPUSH到global:timeline里。<br>面对这个现实，你是否开始觉得:SQL里面用ORDER BY来按时间排序有一点儿奇怪? 我确实是这么想的。</userid></p><p>####分页<br>现在很清楚，我们能用LRANGE来获取帖子的范围，并在屏幕上显示。代码很简单:<br></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">showPost</span><span class="params">($id)</span> </span>&#123;   </span><br><span class="line">   $r = redisLink();   </span><br><span class="line">   $postdata = $r-&gt;get(<span class="string">"post:$id"</span>);   </span><br><span class="line">   <span class="keyword">if</span> (!$postdata) <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line"> </span><br><span class="line">   $aux = explode(<span class="string">"|"</span>,$postdata);   </span><br><span class="line">   $id = $aux[<span class="number">0</span>];   </span><br><span class="line">   $time = $aux[<span class="number">1</span>];   </span><br><span class="line">   $username = $r-&gt;get(<span class="string">"uid:$id:username"</span>);   </span><br><span class="line">$post = join(array_splice($aux,<span class="number">2</span>,count($aux)<span class="number">-2</span>),<span class="string">"|"</span>);   </span><br><span class="line">$elapsed = strElapsed($time);   </span><br><span class="line">$userlink = <span class="string">"&lt;a class=\"username\" href=\"profile.php?u="</span>.urlencode($username).<span class="string">"\"&gt;"</span>.utf8entities($username).<span class="string">"&lt;/a&gt;"</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>(<span class="string">'&lt;div class="post"&gt;'</span>.$userlink.<span class="string">' '</span>.utf8entities($post).<span class="string">"&lt;br&gt;"</span>);   </span><br><span class="line"><span class="keyword">echo</span>(<span class="string">'&lt;i&gt;posted '</span>.$elapsed.<span class="string">' ago via web&lt;/i&gt;&lt;/div&gt;'</span>);   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line"> &#125;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showUserPosts</span><span class="params">($userid,$start,$count)</span> </span>&#123;   </span><br><span class="line">    $r = redisLink();   </span><br><span class="line">    $key = ($userid == <span class="number">-1</span>) ? <span class="string">"global:timeline"</span> : <span class="string">"uid:$userid:posts"</span>;   </span><br><span class="line">    $posts = $r-&gt;lrange($key,$start,$start+$count);   </span><br><span class="line">    $c = <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">foreach</span>($posts <span class="keyword">as</span> $p) &#123;   </span><br><span class="line">        <span class="keyword">if</span> (showPost($p)) $c++;   </span><br><span class="line">        <span class="keyword">if</span> ($c == $count) <span class="keyword">break</span>;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> count($posts) == $count+<span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当showUserPosts获取帖子的范围并传递给showPost时，showPost会简单输出一篇帖子的HTML代码。</p><p>Following users 关注的用户<br>如果用户id 1000 (antirez)想要follow用户id1000的pippo，我们做到这个仅需两步SADD:</p><blockquote></blockquote><p>SADD uid:1000:following 1001<br>SADD uid:1001:followers 1000</p><p>再次注意这个相同的模式:在关系数据库里的理论里follow的用户和被follow的用户是一张包含类似following_id和follower_id的单独数据表。<br>用查询你能明确follow和被follow的每一个用户。在key-value数据里有一点特别，需要我们分别设置1000follow了1001并且1001被1000follow的关系。<br>这是需要付出的代价，但是另一方面讲，获取这些数据即简单又超快。并且这些是独立的集合，允许我们做一些有趣的事情，比如使用SINTER获取两个不同用户的集合。<br>这样我们也许可以在我们的twitter复制品中加入一个功能:当你访问某个人的资料页时显示”你和foobar有34个共同关注者”之类的东西。<br>你能够在follow.php中找到增加或者删除following/folloer关系的代码。它如你所见般平常。</p><p>###使它能够水平分割<br>亲爱的读者，如果你看到这里，你已经是一个英雄了，谢谢你。在讲到水平分割之前，看看单台服务器的性能是个不错的主意。<br>Retwis让人惊讶地快，没有任何缓存。在一台非常缓慢和高负载的服务器上，以100个线程并发请求100000次进行apache基准测试，平均占用5ms。<br>这意味着你可以仅仅使用一台linux服务器接受每天百万用户的访问，并且慢的跟个傻猴似的，就算用更新的硬件。<br>虽然，就算你有一堆用户，也许也不需要超过1台服务器来跑应用，但让我们假设我们是Twitter，需要处理海量的访问量呢?该怎么做?</p><p>###Hashing the key<br>第一件事是把KEY进行hash运算并基于hash在不同服务器上处理请求。有大量知名的hash算法，例如ruby客户端自带的consistent hashing<br>大致意思是你能把key转换成数字，并除以你的服务器数量<br> server_id = crc32(key) % number_of_servers<br>这里还有大量因为添加一台服务器产生的问题，但这仅仅是大致的意思，哪怕使用一个类似consistent hashing的更好索引算法，<br>是不是key就可以分布式访问了呢?所有用户数据都分布在不同的服务器上，没有inter-keys使用到(比如SINTER，否则你需要注意要在同一台服务器上进行)<br>这是Redis不像memcached一样强制指定索引算法的原因，需要应用来指定。另外，有几个key访问的比较频繁。</p><p>####特殊的Keys<br>比如每次发布新帖，我们都需要增加global:nextPostId。单台服务器会有大量增加的请求。如何修复这个问题呢?一个简单的办法是用一台专门的服务器来处理增加请求。<br>除非你有大量的请求，否则矫枉过正了。另一个小技巧是ID并不需要真正地增加，只要唯一即可。这样你可以使用长度为不太可能发生碰撞的随机字符串(除了MD5这样的大小，几乎是不可能)。<br>完工，我们成功消除了水平分割带来的问题。<br>另一个问题是global:timeline。这里有个不是解决办法的解决办法，你可以分别保存在不同服务器上，并且在需要这些数据时从不同的服务器上取出来，或者用一个key来进行排序。<br>如果你确实每秒有这么多帖子，你能够再次用一台独立服务器专门处理这些请求。请记住，商用硬件的Redis能够以100000/s的速度写入数据。我猜测对于twitter这足够了。</p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>