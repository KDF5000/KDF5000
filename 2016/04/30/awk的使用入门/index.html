<html><head><meta name="generator" content="Hexo 3.9.0"><title>awk的使用入门</title><meta name="keywords" content="KDF5000, OpenHex"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link href="/css/main.css?v=3" rel="stylesheet" type="text/css"><script src="/js/util.js"></script><script>isMobile()?loadjscssfile("../css/mobile.css","css"):loadjscssfile("../css/desktop.css","css")</script><link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3"></head><body><h2 class="title">awk的使用入门</h2><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用方法"><span class="toc-text">使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常用命令选项"><span class="toc-text">常用命令选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk的模式和操作"><span class="toc-text">awk的模式和操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#操作"><span class="toc-text">操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#入门实例"><span class="toc-text">入门实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#脚本编程"><span class="toc-text">脚本编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#awk内置变量"><span class="toc-text">awk内置变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结语"><span class="toc-text">结语</span></a></li></ol><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>awk</code>是一个强大的文本分析工具，在对数据分析生成报告时，特别枪弹。<code>awk</code>的原理是把文件以行读入，以指定的分隔符对每行分片，提供一些函数或者自己写程序逻辑，可以对每片进行出来。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk [options] &apos;script&apos; var=value file(s) </span><br><span class="line">awk [options] -f scriptfile var=value file(s)</span><br></pre></td></tr></table></figure><h5 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h5><ul><li><strong>-F field_separator</strong> 制定每行文本的域分隔符，可以是字符串也可以是正则表达式</li><li><strong>-v var=value</strong> 赋值一个用户变量，将外部变量值传入awk</li><li><strong>-f</strong> 制定awk脚本文件</li></ul><h4 id="awk的模式和操作"><a href="#awk的模式和操作" class="headerlink" title="awk的模式和操作"></a>awk的模式和操作</h4><p>awk 脚本，也就是上一节中的script部分，格式遵循下面的形式</p><blockquote><p>awk “pattern action” files</p></blockquote><p>#####模式(Pattern)<br>模式可以是下面的任意一个:</p><ul><li>/正则表达式/: 使用//包围的正则表达式</li><li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试</li><li>模式匹配表达式： 用运算符<code>~</code>(匹配)和<code>~!</code>(不匹配)</li><li>BEGIN语句块，pattern匹配块，END语句块</li></ul><a id="more"></a><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>操作有一个或者多个命令，函数，表达式组成，有换行符或者分毫分开，必须位于大括号内部，主要有下面操作：</p><ul><li>变量或数组赋值</li><li>输出命令</li><li>内置函数</li><li>控制流程语句</li></ul><p>awk操作中的变量或者数组可以直接使用，不用进行初始化，其他语法和c风格比较像</p><h4 id="入门实例"><a href="#入门实例" class="headerlink" title="入门实例"></a>入门实例</h4><p>假设last -n 5的输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop@kdf5000:~$ last -n 5</span><br><span class="line">hadoop   pts/9        :1               Sat Apr 30 15:18   still logged in   </span><br><span class="line">hadoop   pts/22       :1               Sat Apr 30 14:49 - 14:49  (00:00)    </span><br><span class="line">hadoop   :1           :1               Sat Apr 30 14:48   still logged in   </span><br><span class="line">hust-lh  :0           :0               Sat Apr 30 14:46   still logged in   </span><br><span class="line">hadoop   pts/1        :0               Sat Apr 30 14:03 - 14:46  (00:43)</span><br></pre></td></tr></table></figure><p></p><p>如果只显示最近登陆的5个账号<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~$ last -n 5 | awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">hadoop</span><br><span class="line">hadoop</span><br><span class="line">hadoop</span><br><span class="line">hust-lh</span><br><span class="line">hadoop</span><br></pre></td></tr></table></figure><p></p><p>awk工作流程是这样的：读入有<code>\n</code>换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，<code>$0</code> 则表示所有域,<code>$1</code>表示第一个域,<code>$n</code>表示第n个域。默认域分隔符是”空白键” 或 “[tab]键”,所以<code>$1</code>表示登录用户，<code>$3</code>表示登录用户ip,以此类推。</p><p>如果只是显示/etc/passwd的账户<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~$ cat /etc/passwd |awk  -F &apos;:&apos;  &apos;&#123;print $1&#125;&apos;  </span><br><span class="line">root</span><br><span class="line">daemon</span><br><span class="line">bin</span><br><span class="line">sys</span><br><span class="line">sync</span><br><span class="line">games</span><br><span class="line">man</span><br></pre></td></tr></table></figure><p></p><p>这种是<code>awk+action</code>的示例，每行都会执行<code>action{print $1}</code>。<code>-F</code>指定域分隔符为<code>&#39;:&#39;</code>。<br>如果只是显示<code>/etc/passwd</code>的账户和账户对应的<code>shell</code>,而账户与<code>shell</code>之间以逗号分割,而且在所有行添加列名<code>name</code>,<code>shell</code>,在最后一行添加<code>&quot;blue,/bin/nosh&quot;</code>。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~$ cat /etc/passwd |awk  -F &apos;:&apos;  &apos;BEGIN &#123;print &quot;name,shell&quot;&#125;  &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;blue,/bin/nosh&quot;&#125;&apos;</span><br><span class="line">name,shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">daemon,/usr/sbin/nologin</span><br><span class="line">bin,/usr/sbin/nologin</span><br><span class="line">sys,/usr/sbin/nologin</span><br><span class="line">sync,/bin/sync</span><br><span class="line">blue,/bin/nosh</span><br></pre></td></tr></table></figure><p></p><p>awk工作流程是这样的：先执行<code>BEGING</code>，然后读取文件，读入有<code>\n</code>换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，<code>$0</code>则表示所有域,<code>$1</code>表示第一个域,<code>$n</code>表示第<code>n</code>个域,随后开始执行模式所对应的动作<code>action</code>。接着开始读入第二条记录······直到所有的记录都读完，最后执行<code>END</code>操作。</p><p>搜索/etc/passwd有root关键字的所有行<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~$ awk -F: &apos;/root/&apos; /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure><p></p><p>这种是<code>pattern</code>的使用示例，匹配了<code>pattern</code>(这里是<code>root</code>)的行才会执行<code>action</code>(没有指定<code>action</code>，默认输出每行的内容)。</p><p>搜索支持正则，例如找<code>root</code>开头的: <code>awk -F: &#39;/^root/&#39; /etc/passwd</code><br>搜索/etc/passwd有root关键字的所有行，并显示对应的<code>shell</code><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~$ awk -F: &apos;/root/&#123;print $7&#125;&apos; /etc/passwd          </span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p></p><p>这里指定了action{print $7}</p><h4 id="脚本编程"><a href="#脚本编程" class="headerlink" title="脚本编程"></a>脚本编程</h4><p>awk可是将脚本写到文件中，然后使用-f调用脚本文件<br>下面是一个统计一个文件中对应的单词出现的次数，文件的每一行有两个字段，一个是单词，一个是次数，每个单词可能出现多次，求每个单词后面每个数组的和<br>下面是输入文件示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello 1</span><br><span class="line">world 2</span><br><span class="line">hello 2</span><br><span class="line">world 1</span><br><span class="line">haha  4</span><br><span class="line">demo  3</span><br></pre></td></tr></table></figure><p></p><p>脚本如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/awk</span><br><span class="line">BEGIN&#123;</span><br><span class="line">    print &quot;word&quot;, &quot;count&quot;</span><br><span class="line">    count=0</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    word[$1] = word[$1] + $2;</span><br><span class="line">    count = count + $2</span><br><span class="line">&#125;</span><br><span class="line">END&#123;</span><br><span class="line">   for (v in word)&#123;</span><br><span class="line">      print v, word[v]</span><br><span class="line">   &#125;</span><br><span class="line">   print &quot;Total Count:&quot;, count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>执行脚本<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hadoop@hust-lh:~/BigData/Homework/Hw2/GraphLite/GraphLite-0.20/res$ awk -f count.awk word</span><br><span class="line">word count</span><br><span class="line">demo 3</span><br><span class="line">haha 4</span><br><span class="line">hello 3</span><br><span class="line">world 3</span><br><span class="line">Total Count: 13</span><br></pre></td></tr></table></figure><p></p><p>其实和c语言的风格时一样的，程序控制语句支持if, for, while, do while。</p><h5 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h5><p>下面是awk的内置变量，这些变量时可以直接在脚本里使用的</p><blockquote></blockquote><p>ARGC ：命令行参数个数<br>ARGV ：命令行参数排列<br>ENVIRON ：支持队列中系统环境变量的使用<br>FILENAME ：awk浏览的文件名<br>FNR ： 浏览文件的记录数<br>FS ：设置输入域分隔符，等价于命令行 -F选项<br>NF ：浏览记录的域的个数<br>NR：已读的记录数<br>OFS ：输出域分隔符<br>ORS ：输出记录分隔符<br>RS ：控制记录分隔符</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p><code>awk</code>是一个非常强大好用的文本处理工具，<code>awk</code>的更多使用方法参考<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/manual/gawk.html</a></p><div style="display:none"><script src="http://s4.cnzz.com/stat.php?id=undefined&web_id=undefined" language="JavaScript"></script>script></div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>